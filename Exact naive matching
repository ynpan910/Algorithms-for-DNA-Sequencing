#1.download fasta file. this is a reference genome for lamda virus----------------------------------------------------------------------------------------------------------
import urllib.request

url = 'http://d28rh4a8wq0iu5.cloudfront.net/ads1/data/lambda_virus.fa'

filename = 'lambda_virus.fa'

urllib.request.urlretrieve(url, filename)

#2. to anwer the questions, we need to first define some functions---------------------------------------------------------------------------------------------------------------------------------------------------------------

##2.1 read the reference genome
def readGenome(filename):
    genome=''
    with open (filename, 'r') as f:
        for line in f:
            if not line[0]=='>':
                genome+=line.rstrip()
    return genome


##2.2 naive matching
def naive(p, t): 
    occurences=[]  ##a list that keep the indices where p matches t
    for i in range(len(t)-len(p)+1): #outer loop. this loop over all positions in t that p could start, without running past the end of t
        match=True ##initialize the value
        for j in range(len(p)):
            if p[j]!=t[i+j]:
                match=False
                break #if we find the first character is not matched, we do not need to continue this round of inner loop, so put break
        if match:
            occurences.append(i)
    return occurences

##2.3 get complementary reversed sequences
def reverseComplement(s):
    complement={'A':'T', 'C':'G', 'T':'A', 'G':'C', 'N':'N'}
    t=''
    for base in s:
        t=complement[base]+t
    return t

##2.4 to find strand-awared exact naive matching of given strings in a ref genome. the function will return how many matches are there. Plus, if a string and its reverse complement are identical (e.g., AACGTT), only once will be reported.

nMatches=[]

def strandAwaredNaiveExactMatching (read, genome):
    alig1=naive(read, genome)
    alig_ComRev=naive(reverseComplement(read), genome)
    if read != reverseComplement(read):
        nMatches=len(alig1)+len(alig_ComRev)
    else:
        nMatches=len(alig1)
    return nMatches

#3. answering questions----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

genome=readGenome('lambda_virus.fa')


##q1, q2:
read='TTAA'   #just need to change the strings given in the questions
strandAwaredNaiveExactMatching(read, genome)

##q3, q4:
print(naive('ACTAAGT', genome))
print(naive(reverseComplement('ACTAAGT'), genome))

##q5, q6:

### first, define a function to find APPROXIMATE MATCHES for P in T, which allows for <=2 differences, and do NOT consider the reverse complement here


def naive_2mm(p, t): #p could be 'word', and t could be a sentence
    occurences=[]  ##a list that keep the indices where p matches t
    for i in range(len(t)-len(p)+1): #outer loop. this loop over all positions in t that p could start, without running past the end of t
        match=True ##initialize the value
        nMM=0 #the number of mismatch. Got this wrong at the first time by putting it inside the inner loop, that way nMM reset when comparing the next digit in p, which does not add up the total mismatch inside p.
        for j in range(len(p)):
            
            if p[j]!=t[i+j]:
                nMM+=1
                if nMM>2:
                    match=False
                    break #if we find the first character is not matched, we do not need to continue this round of inner loop, so put break
        if match:
            occurences.append(i)
    return occurences

### use the defined fuction to answer the question
naive_2mm('TTCAAGCC', genome)

